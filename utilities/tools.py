import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time
import itertools

def checking_missing_data(dataset, DELETING_MISSING_DATA_SL = 0.5, HIG_MISSING_DATA_SL = 0.1):
    """
    This function check a pandas dataset for missing data and returns a list with all you need to know about your missing data

    Parameters
    ----------
    dataset : pandas.Dataframe.
        a dataset containing missing value.
    HIG_MISSING_DATA_SL : significance level for high amount of missing data.
        The default value is 0.1, a level I personally consider quite good.
    DELETING_MISSING_DATA_SL : significance level for too much missing data.
        The default value is 0.5, a level I personally consider quite good.    

    Returns
    -------
    info : array-like
        An array which contains all the info you want about your missing data:
                The first element is a list of the counted missing value for every column.
                
                The second element is a list of the keys of the columns to be eliminated according to the SL.
                
                The third element is a dictionary which stores the high missing data columns with their rispective ratio.
                
                The third element is a dictionary which stores the high missing data columns with their rispective ratio.
    
    Example
    -------
    info = tools.checking_missing_data(dataset)
    
    counters = info[0]
    
    to_delete = info[1]
    
    few_missing = info[2]
    
    high_missing = info[3]
    
    """
    counters = []
    to_delete = []
    few_missing = {}
    high_missing = {}
    for key in dataset.keys():
        counter = 0
        for value in dataset[key]:
            if pd.isna(value):
                counter += 1
        if counter/dataset.shape[0] >= DELETING_MISSING_DATA_SL:
            to_delete += [key]
        elif counter/dataset.shape[0] >= HIG_MISSING_DATA_SL:
            high_missing[key] = counter
        elif counter/dataset.shape[0] > 0:
            few_missing[key] = counter
        counters += [counter]
    return [counters,to_delete,few_missing,high_missing] 


def mean_reduction(array):
    """
    A function which transform the given array of lenght N into one of lenght N-1 made by the mean of each pairs of the previous one
    """
    new_array = []
    for i in range(1,len(array)):
        new_array += [np.mean([array[i-1],array[i]])]
    return new_array
        
def get_string_date():
    """
    Provides a string containg the local date
    
    """
    date = ""
    tm_date = time.localtime()
    date = date + str(tm_date.tm_mday) +'/' + str(tm_date.tm_mon) +'/'+ str(tm_date.tm_year)
    return date


def plot_cm(cm, classes, title = 'Confusion Matrix', cmap = plt.cm.Reds):
    """
    Prints the confusion matrix.
    
    Parameters
    ----------
    cm : the confusion matrix
        For example the one generated by 'from sklearn.metrics import confusion_matrix'
    classes: an array like
        it contains the classes of the cm
    title : a string, optional, default "Confusion Matrix"
        The title of the graph.
    cmap : ~matplotlib.colors.Colormap, optional, default: Reds
        The range of color to be used in the graph.
        
    Examples    
    ----------
    """
    plt.imshow(cm, cmap = cmap)
    plt.title(title)
    plt.colorbar()
    ticks = np.arange(len(classes))
    xclass = []
    for i in classes:
        xclass += ['True ' + i]
    yclass = []
    for i in classes:
        yclass += ['Pred ' + i]
    plt.xticks(ticks, xclass)
    plt.yticks(ticks, yclass)
    
    thresh = cm.max() / 2.
    for i,j in itertools.product(range(len(classes)), range(len(classes))):
        plt.text(i, j, cm[i,j], horizontalalignment='center', verticalalignment='center', color="white" if cm[i, j] > thresh else "black")


def error_info_df_binary(cat_pred, true_val, prob_pred, effective_prob = False):
    
    """
    Returns a matrix with info about your binary predictions.
    
    Parameters
    ----------
    cat_pred : an array like.
        The binary predictions you made.
    true_val: an array like.
        The actual binary value.
    prob_pred : an array like.
        The probabilities assigned by your model. 
    effective_prob : boolean. default False.
        The flag to indicate if you rescaled the probabilities to be the effective probability instead of being the in a range (0,1). [made simple] Ff predictions from model.predict have a range(0,1) leave it default.
        
    Returns
    -------
    errors_info : pandas Dataframe
        A dataframe which contains 3 columns:
                The 'id' to get back to the original data.\n
                The 'prob' to store the prob of the predictions.\n                
                The 'err_category' to specify the type of errors.
                        'fp' = false positive.
                        'fn' = false negative.
                        'right' = the prediction was right.
    """

    errors_info = pd.DataFrame(columns = ['id','prob', 'err_category'])
    
    for i in range(len(cat_pred)):
        
        errors_info.loc[i,'id'] = i
        if cat_pred[i] == 1:
            errors_info.loc[i,'prob'] = prob_pred[i][0]
        else:
            errors_info.loc[i,'prob'] = 1-prob_pred[i][0]
        
        if (cat_pred[i] == 0 and  true_val[i] == 1 ):
            errors_info.loc[i,'err_category'] = 'fp'
        elif (cat_pred[i] == 1 and  true_val[i] == 0 ):
            errors_info.loc[i,'err_category'] = 'fn'
        else:
            errors_info.loc[i,'err_category'] = 'right'
    return errors_info


# Converting an image to matrix
#from PIL import Image
#img = Image.open('single_prediction/cat_or_dog_1.jpg')
#arr = np.array(img)   
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

        